**October 8**

# Context-Free Languages and Grammars

Context-free grammars (CFGs) enable us to describe languages that finite automata and regular expressions cannot recognize. An example of such a language is:

- **L = { 0ⁿ1ⁿ | n ≥ 0 }**

This language consists of strings with an equal number of zeros followed by an equal number of ones. It can be shown using the pumping lemma that this language is not regular.

To recognize context-free languages like this one, we use computational models called **Pushdown Automata (PDA)**.

## What Is a Grammar?

A grammar is a collection of substitution rules used to generate strings in a language. Each rule specifies how a variable (also called a non-terminal) can be replaced by a combination of variables and terminals.

**Example Grammar:**

```
A → 0A1
A → B
B → #
```

Starting from a **start variable**, we repeatedly apply these substitution rules until we derive a string consisting only of **terminal symbols**—symbols that do not have any substitution rules. In this example, the set of terminals is `{ 0, 1, # }`.

## Derivation and Parse Trees

We can visualize the generation of strings using parse trees or derivations, which show the application of rules step by step.

**Example Derivation:**

```
A ⇒ 0A1 ⇒ 0B1 ⇒ 0#1
```

This shows that the string `0#1` is generated by the grammar.

## Why "Context-Free"?

These grammars are called **context-free** because the substitution rules can be applied to variables regardless of the surrounding symbols (the context). We can choose any applicable rule for a variable without considering the context in which the variable appears.

## Language of the Example Grammar

The language generated by the example grammar is:

- **L = { 0ⁿ#1ⁿ | n ≥ 0 }**

This represents all strings that start with `n` zeros, followed by a `#`, and then `n` ones.

## Conventions in Grammar Notation

- The **start variable** is typically the first symbol on the left-hand side of the first rule.
- Multiple substitution rules for the same variable can be combined using the `|` (OR) operator. For example:
  ```
  S → aSb | SS | ε
  ```
  This means `S` can be replaced by `aSb`, `SS`, or the empty string `ε`.

## Formal Definition of a Context-Free Grammar

A context-free grammar is a 4-tuple `(V, Σ, R, S)` where:

- **V**: A finite set of variables (non-terminals).
- **Σ**: A finite set of terminals, disjoint from V.
- **R**: A finite set of rules (productions), each of the form `A → w`, where `A` is a variable and `w` is a string of variables and terminals.
- **S**: The start variable, where `S ∈ V`.

In derivations:

- If `u`, `v`, and `w` are strings of variables and terminals, and `A → w` is a rule, then `uAv ⇒ uwv`. This means `A` in `uAv` can be replaced by `w`.
- We say `u` derives `v`, written `u ⇒* v`, if there is a sequence of derivations from `u` to `v`.

## Example Grammar

Consider the grammar:

```
G = ({ S }, { a, b }, R, S)
```

With the set of rules `R`:

```
S → aSb | SS | ε
```

This grammar generates strings over `{ a, b }` where the number of `a`'s and `b`'s are balanced in specific ways.

## Strategies for Designing Context-Free Grammars

1. **Break down** the context-free language into simpler components.
2. **Create grammars** for these simpler parts.
3. **Combine** the parts using the `|` operator where applicable.

---

## Conversion of DFA to CFG (Homework Exercise)

For regular languages, constructing a CFG is straightforward. The steps are:

1. **Create a variable** `Rᵢ` for each state `qᵢ` of the DFA.
2. **Add rules** of the form `Rᵢ → a Rⱼ` if the transition function δ(`qᵢ`, `a`) = `qⱼ`. This mirrors the transitions of the DFA.
3. **Add rules** of the form `Rᵢ → ε` for each accept state `qᵢ` of the DFA.
4. **Designate** `R₀` (corresponding to the start state `q₀`) as the start variable of the grammar.

---

## Elaborating on Context-Free Languages

Certain context-free languages contain strings where substrings are "linked" or balanced. For instance, the language:

- **L = { 0ⁿ1ⁿ | n ≥ 1 }**

Can be generated by the grammar:

```
S → 0S1 | ε
```

This grammar builds strings by recursively adding matching `0` and `1` pairs. The symmetry in the structure is significant; it's often an indicator that a language is non-regular but context-free. CFGs are adept at constructing such symmetrical languages.

---

## Ambiguous Grammars and Chomsky Normal Form

A grammar is **ambiguous** if there exists a string that can be generated by the grammar in more than one way (i.e., it has multiple parse trees). To standardize grammars and facilitate parsing, we can convert them into **Chomsky Normal Form (CNF)**.

### Theorem

Every context-free language can be generated by a CFG in Chomsky Normal Form. Therefore, any CFG can be converted into an equivalent CFG that is in CNF.

### Chomsky Normal Form Definition

In CNF, all production rules are of the following forms:

- **Terminal Rules**: `A → a`, where `A` is a variable and `a` is a terminal symbol.
- **Variable Rules**: `A → BC`, where `A`, `B`, and `C` are variables (and `B` and `C` are not the start variable).
- **Start Variable Rule**: The start variable can produce the empty string `ε` (i.e., `S → ε`).

---

## Converting a CFG to Chomsky Normal Form

To convert any CFG to CNF, follow these steps:

1. **Add a New Start Variable**:
   - Introduce a new start variable `S₀` and add the rule `S₀ → S`, where `S` is the original start variable. This ensures that the start variable does not appear on the right-hand side of any production.

2. **Eliminate `ε`-Productions**:
   - Remove all productions of the form `A → ε`, where `A` is not the start variable.
   - For every production that includes `A` on the right-hand side, add new productions where `A` can be omitted.
   - For example, if `A → ε` and there is a production `B → uAvAw`, add productions `B → uvAw`, `B → uAvw`, and `B → uvw`.

3. **Eliminate Unit Productions**:
   - Remove all unit productions (rules where a variable produces a single variable, like `A → B`).
   - For each unit production `A → B`, add all productions of `B` to `A`, except for unit productions.

4. **Convert to Proper Form**:
   - Ensure all productions are in CNF:
     - For terminals: `A → a`.
     - For variables: `A → BC`, where `B` and `C` are variables.
   - For productions with more than two symbols on the right-hand side, introduce new variables to break them down.
   - For terminals appearing with variables (e.g., `A → aB`), replace terminals with variables that produce those terminals.

---

## Example: Converting a Grammar to Chomsky Normal Form

Given the grammar:

```
S → A S A | a B
A → B | S
B → b | ε
```

### Step 1: Add a New Start Variable

Introduce `S₀`:

```
S₀ → S
```

### Step 2: Eliminate `ε`-Productions

Identify nullable variables (those that can derive `ε`):

- `B → ε`

Update productions to account for `B` possibly being `ε`:

```
S → A S A | A S | S A | S
A → B | S | ε
B → b
```

Add productions where `B` is omitted in `a B`:

```
S → A S A | A S | S A | S | a B | a
```

### Step 3: Eliminate Unit Productions

Remove unit productions (`A → B`, `A → S`, `S → A`):

- For `A → B` and `B → b`, add `A → b`.
- For `A → S`, add all productions of `S` to `A`.
- For `S → A`, add all productions of `A` to `S`.

Updated productions:

```
S₀ → S
S → A S A | A S | S A | S | a B | a | b S A | a S | S A | b
A → A S A | A S | S A | S | a B | a | b
B → b
```

### Step 4: Convert to Proper Form

Break down productions to fit CNF:

- Replace terminals with variables:

  Introduce `C → a`, `D → b`.

- Update productions:

  - Replace `a` with `C`.
  - Replace `b` with `D`.

Example updated productions:

```
S₀ → S
S → A S A | A S | S A | S | C B | C
A → A S A | A S | S A | S | C B | C | D
B → D
C → a
D → b
```

- Break down longer productions:

  For example, replace `A S A` with `A E`, where `E → S A`.

Final productions in CNF will have all productions in the form `A → BC` or `A → a`.

---

# Questions

1. **How is `R` denoted in the grammar tuple `(V, Σ, R, S)`? Is there a standard convention for representing `R`? In the example, it's unclear how `R` specifically corresponds to the given rules.**

   **Answer:** In the tuple `(V, Σ, R, S)`, `R` represents the set of production rules of the grammar. Each rule in `R` is of the form `A → w`, where `A` is a variable in `V`, and `w` is a string of symbols from `(V ∪ Σ)*`. There isn't a strict convention for listing `R`; it often depends on context. In examples, `R` is typically defined by listing all the production rules explicitly or combining them using the `|` operator.

2. **What exactly is a unit rule?**

   **Answer:** A unit rule (or unit production) is a production rule where a single variable produces another single variable, such as `A → B`, where `A` and `B` are variables (non-terminals). Unit rules can create unnecessary steps in derivations and can be eliminated by replacing them with the productions of the variable on the right-hand side (`B`).

3. **What is considered proper form in the context of converting to Chomsky Normal Form?**

   **Answer:** Proper form refers to the structure of production rules in CNF. All productions must be either:

   - **Terminal Productions**: `A → a`, where `A` is a variable and `a` is a terminal symbol.
   - **Variable Productions**: `A → B C`, where `A`, `B`, and `C` are variables (and `B` and `C` are not the start variable).
   - The start variable can produce the empty string `ε` (only if necessary).

   Any production not in these forms must be converted by introducing new variables and adjusting the rules accordingly.

---

**Additional Resource:**

- **Easy Theory Video on CFG to CNF Conversion:** [CFG to CNF](https://www.youtube.com/watch?v=-SZkkMWHBvQ)

---
