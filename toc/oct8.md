October 8

# Context Free Languages

Context free grammars allow us to express languages that finite automata and regular expresions cannot.
One such example is L = {0^n1^n | n >= 0 }.   
If we were to pump this language using the pumping lemma, we'd find that it is not regular.

The machinery used are called **Pushdown Automata** (PDA). These can recognize context free languages.

## What is a grammar?

We define a grammar as a collection of substitution rules.
One example:
A -> 0A1
A -> B  
B -> #

Given a start variable, repeat the replacements until no variables remain.
That is, keep doing replacements under the rule system until only **terminal** symbols are leftover.
**Terminals** are symbols for which there are no replacement rules defined.
  
In the given example, {0, 1, #} is the set of terminals.

## Example
We can create a parse tree by starting A, then keep applying the rules arbitrarily to find strings that are accepted in the language.
In this sense, the substitution rules generate something accepted by the language -- these are called **productions**.

A => 0A1 => 0B1 => 0#1.
  
This particular grammar can generate the string `0#1`.
For this particular grammar, we can just generate arbitrary amounts of `#`s.

### Intuition on the "context-free" name

Why do we call these context-free grammars? It's because underneath the substitution rules, we don't really care about keeping track of past states. We can just pick artbirarily what sibstution to make, so long as there is a rule defined for that substitution.

### Language of the example

The language recognized by this grammar can be concisely written as {0^n#1^n | n >= 0}.

### Conventions 

- The starting variable comes from the top-left symbol in the grammar, i.e. the first symbol in the left-hand side of the rules definition.
- If we have several rules underneath the symbol, we can just write them together with the "|" (OR) operator. This implies we have a choice between one substitution and another.

### Rigorous definition

CFGs are a 4-tuple (V,sigma,R,S) where
- V is a finite set called the variables
- Sigma is a finite set, disjoint from V, called the terminals. 
- R is a finite set of rules, with each rule being a variable and a string of variables and terminals
- S in V is the start variable

If u,v, and w are strings of variables and terminals, and A -> w is a rule defined under the grammar, then
- We say that uAv "yields" uwv, which is written as uAv => uwv. I.e we can replace A with w.
- We say that u "derives" v, written as u=>* v. this means that there is a sequence of u's such that v can be a reuslt of that sequence. I.e u derives v is v can be created with the rule u.

### Example

Consider the gramer G = ({S}, {a,b}, R, S).
The set of rules R for the grammar is S -> aSb || SS | epsilon

#### How do we denote R in the tuple? Is that a convention we need to know? Additionally, the example in class is unclear about R specifically being this rule-- that is, there's no clear replacement operation on R and the given ruleset.

### Strategies for designing CFG

1. If possible, break a context-free language into smaller pieces.
2. Then, create grammars for the simpler parts
3. finally, combine those parts with OR operators where applicable.

---
---

## Conversion of DFA to CFG (Homework Exercise)

If the language is regular, a CFG should be fairly easy to construct.
1. Make a variable R_{i} for each state q_{i} of the DFA.   That is, for each state in the DFA, we want a variable R.
2. Add the rule R_{i} -> aR+{j} if triangle_symbol(q+{i},a) = q_{j} . That is, add a rule that satisfies the transition function for that particular state.
3 Add the rule R+{i} -> epsilon if q_{i} is an acept state of the DFA. That is, ... 
4. Make R_{0} the start variable of the grammar

### Elaboration

Certain CFLs contain strings that themselves also contain substrings-- we can say these are "linked" in some way.
For instance, for the language  L = {0^n1^n | n >= 1 }, the grammar is just   
S -> 0S1 | epsilon

We can imagine the transitions are growing outwards in equal magnitude, i.e., 
the string we are building at minimum has 01 in it, then we can add things to the center, keeping symmetry.
Symmetry is really important-- often, symmetry is some indication of a language that is non-regular.
CFGs are really good at building "symmetrical" languages. 

### Ambiguous grammar
### Chomsky normal form
What is it?   
### Definition
#### Theorem
Any CFL is generated by a CFG in chomsky normal form.
That is, we can always convert any CFG to a chomsky normal form.
This is pretty subtle. basically, grammars can be ambiguous, meaning that multiple grammars can generate the same language. We could have a grammar thats not in chomsky normal form, but then "fix" it so that it is. These will create equivalent languages despite appearing to have a different ruleset.
#### Example: Converting a non-chomsky form grammar to a chomsky form grammar (?)
1. Add a new start variable S_{0} -> S
this will gaurantee that there is no S_{0} on the right hand side.
2. Remove any \lamba rules (i.e. those that look like A->lambda, where A is __not__ a start variable).
For each rule where A appers on the right hand side, add a rule with that occurence deleted.
As an example, 

given, 

A=>lambda
R => uAVAw 

will be converted
to R => uvAw | uAvW | uvw

this removes lambda from terminal variables.

3. __Unit rules__: say wae want to remove A->B, then
for every rule of the form B->u, we add the rule  A->u
This effectively removes B from the left hand side.
Repeat that until all unit rules are elmiminated.

** What exactly is a unit rule?**

4. Convert all remaining rules into proper form.
** What is considered proper form**?
For a rule that looks like A->u_{1}u_{2}...u_{k},
We can have  A->u_{0}A_{0}
            A_{1} ->  u_{2}... (complete this)

### Example
Given:
S->ASA | aB
A -> B|S
B->b| \lambda

1. We need a new start variable, so we modify the rule such that:

**S_{0} -> S**
S->ASA | aB
A -> B|S
B->b| \lambda

2. Now, we need to eliminate all the lambda rules, that is-- eliminate all rules that **derive** lambda.

S_{0} -> S
**S->ASA | aB | a**
**A -> B|S | lambda**
** B -> b **

lambda is introduced to 3rd rule.
a is introduced in the 2nd rule.
this is because it involved a B token.
we need to test each rule ensure that we have not modified the language unexpectedly.


** Now, we remove A->lambda ** anywhere it was created.


S_{0} -> S
S->ASA | aB | a  **SA | AS | S**
A -> B|S | lambda
B -> b 

3. Lastly, remove the "unit rules":
We need to remove anything with S->S

- remove S-{0} -> S
- S-> S

results in 
S_{0} -> ASA | SA | AS | ab | a
S => ASA | SA | AS | ab | a
A -> B | S
B -> b

Now, remove A->B,

S_{0} -> ASA | SA | AS | ab | a
S => ASA | SA | AS | ab | a
A -> B | S
B -> b

#### EasyTheory Videos
[CFG to CNF](https://www.youtube.com/watch?v=-SZkkMWHBvQ)